from typing import List, Dict, Any, Optional
from .. import schemas
import httpx
import random
import asyncio

async def generate_build(
    db,
    build_request: schemas.BuildRequest,
    component_service_url: str,
    pricing_service_url: str,
    benchmark_service_url: str
) -> schemas.Build:
    """Generar una build recomendada basada en los requisitos del usuario"""
    # Paso 1: Obtener componentes base según el caso de uso
    core_components = await get_core_components(
        build_request.use_case,
        component_service_url
    )
    
    # Paso 2: Seleccionar componentes específicos
    selected_components = await select_specific_components(
        core_components,
        build_request,
        component_service_url,
        pricing_service_url
    )
    
    # Paso 3: Calcular precio total
    total_price = await calculate_total_price(
        selected_components,
        build_request.country_code,
        pricing_service_url
    )
    
    # Paso 4: Validar y ajustar al presupuesto
    optimized_components = await optimize_for_budget(
        selected_components,
        total_price,
        build_request.budget,
        component_service_url,
        pricing_service_url
    )
    
    # Paso 5: Estimar rendimiento
    estimated_performance = await estimate_performance(
        optimized_components,
        build_request.use_case,
        benchmark_service_url
    )
    
    return schemas.Build(
        name=f"Build recomendada para {build_request.use_case}",
        description=f"Build generada automáticamente para {build_request.use_case}",
        components=optimized_components,
        total_price=total_price,
        currency=build_request.currency,
        use_case=build_request.use_case,
        country_code=build_request.country_code,
        estimated_performance=estimated_performance
    )

async def get_core_components(use_case: str, service_url: str) -> Dict[str, List[int]]:
    """Obtener componentes base para un caso de uso específico"""
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"{service_url}/components/core",
            params={"use_case": use_case}
        )
        return response.json()

async def select_specific_components(
    core_components: Dict[str, List[int]],
    build_request: schemas.BuildRequest,
    component_service_url: str,
    pricing_service_url: str
) -> List[Dict]:
    """Seleccionar componentes específicos basados en preferencias y disponibilidad"""
    selected = []
    
    # Para cada categoría, seleccionar el mejor componente dentro del presupuesto
    for category, component_ids in core_components.items():
        # Obtener detalles de los componentes
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{component_service_url}/components/details",
                json={"component_ids": component_ids}
            )
            components = response.json()
        
        # Filtrar por marca preferida si existe
        if build_request.preferred_brands and category in build_request.preferred_brands:
            brand = build_request.preferred_brands[category]
            components = [c for c in components if c["manufacturer"] == brand]
        
        # Seleccionar componente (estrategia simplificada)
        if components:
            # En una implementación real, usaríamos un algoritmo de optimización
            selected_component = random.choice(components)
            selected.append({
                "component_id": selected_component["id"],
                "name": selected_component["name"],
                "category": selected_component["category"],
                "price": selected_component.get("price", 0),
                "quantity": 1
            })
    
    return selected

async def calculate_total_price(
    components: List[Dict],
    country_code: str,
    pricing_service_url: str
) -> float:
    """Calcular el precio total actualizado para los componentes"""
    component_ids = [comp["component_id"] for comp in components]
    
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{pricing_service_url}/prices/batch",
            json={
                "component_ids": component_ids,
                "country": country_code
            }
        )
        prices = response.json()
    
    total = 0
    for comp in components:
        comp_id = comp["component_id"]
        if str(comp_id) in prices:
            total += prices[str(comp_id)]["current_price"] * comp["quantity"]
        else:
            total += comp.get("price", 0) * comp["quantity"]
    
    return total

async def optimize_for_budget(
    components: List[Dict],
    current_total: float,
    target_budget: float,
    component_service_url: str,
    pricing_service_url: str
) -> List[Dict]:
    """Ajustar la build para que se ajuste al presupuesto"""
    # Estrategia simplificada: reducir componentes si es necesario
    if current_total <= target_budget:
        return components
    
    # Calcular exceso
    excess = current_total - target_budget
    
    # Intentar reducir componentes costosos
    sorted_components = sorted(components, key=lambda x: x.get("price", 0), reverse=True)
    
    for comp in sorted_components:
        if comp.get("price", 0) > excess:
            # Buscar alternativa más barata
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{component_service_url}/components/alternatives",
                    params={
                        "component_id": comp["component_id"],
                        "max_price": comp["price"] - excess
                    }
                )
                alternatives = response.json()
                
                if alternatives:
                    # Seleccionar la primera alternativa viable
                    comp["component_id"] = alternatives[0]["id"]
                    comp["name"] = alternatives[0]["name"]
                    comp["price"] = alternatives[0].get("price", comp["price"])
                    break
    
    return components

async def estimate_performance(
    components: List[Dict],
    use_case: str,
    benchmark_service_url: str
) -> Dict[str, Any]:
    """Estimar el rendimiento de la build"""
    component_ids = [comp["component_id"] for comp in components]
    
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{benchmark_service_url}/benchmark/estimate",
            json={
                "component_ids": component_ids,
                "use_case": use_case
            }
        )
        return response.json()

async def get_recommendations(
    db,
    user_id: int,
    component_service_url: str
) -> List[schemas.Build]:
    """Obtener builds recomendadas basadas en preferencias de usuario"""
    # En una implementación real, usaríamos un sistema de recomendación basado en:
    # - Historial del usuario
    # - Builds populares
    # - Similitud de casos de uso
    # Esta es una versión simplificada
    
    # Obtener builds públicas populares
    public_builds = db.query(models.Build).filter(
        models.Build.is_public == True
    ).order_by(models.Build.likes.desc()).limit(10).all()
    
    return public_builds